# Документация: Frontend (Yew)

Frontend-часть приложения реализована с использованием фреймворка Yew, который позволяет писать веб-интерфейсы на Rust и компилировать их в WebAssembly (WASM).

## Структура (`src/`)

*   `main.rs`: Точка входа для frontend-приложения. Инициализирует рендерер Yew и монтирует корневой компонент `App`.
*   `app.rs`: Содержит всю логику и разметку пользовательского интерфейса.

---

### `app.rs` - Компонент `App`

Это единственный и главный компонент приложения, реализованный как функциональный компонент с использованием хуков.

#### Состояние (State)

Состояние компонента управляется с помощью хука `use_state`:

*   `editor_content: UseStateHandle<String>`: Хранит текущее содержимое текстового редактора.
*   `server_info: UseStateHandle<String>`: Хранит информационную строку с IP-адресом сервера для отображения пользователю.
*   `save_status: UseStateHandle<String>`: Хранит статус сохранения (например, "Сохранено!"), который отображается после нажатия кнопки.

#### Взаимодействие с Backend (Tauri)

Связь между Yew (WASM) и Tauri (Rust backend) осуществляется через JavaScript-интерфейс, предоставляемый Tauri.

*   **`invoke(cmd: &str, args: JsValue) -> JsValue`**:
    *   Эта функция объявлена в блоке `#[wasm_bindgen] extern "C"`. Она является биндингом к JavaScript-функции `window.__TAURI__.core.invoke`.
    *   `invoke` позволяет вызывать любую Tauri-команду, зарегистрированную на бэкенде, передавая ей имя команды и аргументы.
    *   Вызов является асинхронным и возвращает `Promise` (в Rust-контексте `Future`, который можно `await`).

#### Жизненный цикл и эффекты

*   **`use_effect_with((), ...)`**: Этот хук используется для выполнения сайд-эффектов.
    *   Пустой кортеж `()` в качестве зависимостей означает, что эффект выполнится только один раз, после первого рендера компонента (аналог `useEffect(..., [])` в React).
    *   Внутри эффекта запускается асинхронная задача (`spawn_local`), которая:
        1.  Вызывает команду `get_text` для получения начального текста из `AppState`.
        2.  Вызывает команду `get_server_info` для получения IP-адреса.
        3.  Обновляет соответствующие состояния компонента (`editor_content` и `server_info`) полученными данными.

#### Обработчики событий (Callbacks)

*   **`on_input: Callback<InputEvent>`**:
    *   Срабатывает при каждом изменении текста в `<textarea>`.
    *   Получает новое значение из элемента и обновляет состояние `editor_content`.
    *   Сбрасывает `save_status`, так как текст был изменен после сохранения.

*   **`on_save: Callback<MouseEvent>`**:
    *   Срабатывает при клике на кнопку "Сохранить".
    *   Запускает асинхронную задачу (`spawn_local`), которая:
        1.  Читает текущее значение из `editor_content`.
        2.  Вызывает команду `set_text` на бэкенде, передавая новый текст.
        3.  После успешного выполнения вызова обновляет `save_status` на "Сохранено!".

#### Рендеринг (HTML)

*   Макрос `html! { ... }` используется для декларативного описания структуры DOM.
*   Значения из состояний (`*editor_content`, `*server_info`) напрямую встраиваются в разметку.
*   Обработчики событий (`oninput`, `onclick`) привязываются к соответствующим элементам.
