# Документация: Backend (Tauri + Axum)

Бэкенд-часть приложения построена на Rust и состоит из трех основных компонентов: ядра Tauri для управления десктопным приложением, встроенного веб-сервера Axum для обслуживания E-Ink читалок и фоновых потоков для таких задач, как мониторинг буфера обмена.

## Структура модулей (`src-tauri/src`)

*   `main.rs`, `lib.rs`: Точки входа. Инициализируют состояние приложения (`AppState`), запускают веб-сервер и фоновые потоки, настраивают обработчики команд Tauri.
*   `state.rs`: Определяет центральное состояние приложения.
*   `commands.rs`: API для взаимодействия с Frontend (для управляющих команд).
*   `server.rs`: Реализация веб-сервера на Axum (API для данных).
*   `core.rs`: Чистая бизнес-логика (обработка Markdown).
*   `url_processor.rs`: Логика для загрузки и обработки URL.
*   `clipboard.rs`: Логика мониторинга буфера обмена.
*   `network.rs`: Сетевые утилиты.

---

### `state.rs`

Отвечает за управление общим состоянием приложения.

*   **`AppState`**: Структура, содержащая все разделяемые данные.
    *   `shared_text: RwLock<String>`: Основной текст в формате Markdown. `RwLock` используется для обеспечения безопасного конкурентного доступа.
    *   `monitor_clipboard: Arc<AtomicBool>`: Атомарный флаг для включения/выключения мониторинга буфера обмена.

---

### `commands.rs`

Определяет функции, которые можно вызывать из JavaScript-фронтенда через `invoke`. Эти команды используются для получения начальных данных или управления состоянием приложения, не связанным с основным контентом.

*   **`get_text(state: State<Arc<AppState>>) -> Result<String, String>`**:
    *   Возвращает текущий текст из `AppState`. Используется фронтендом при инициализации.

*   **`get_server_info() -> Result<String, String>`**:
    *   Определяет локальный IP-адрес и формирует URL для подключения с читалки.

*   **`set_clipboard_monitoring(enabled: bool, state: State<Arc<AppState>>) -> Result<(), String>`**:
    *   Включает или выключает мониторинг буфера обмена, изменяя значение `monitor_clipboard` в `AppState`.

---

### `server.rs`

Реализует веб-сервер, который является основным каналом для обновления контента.

*   **`run_server(app_state: Arc<AppState>)`**: Асинхронная функция, которая запускает сервер Axum на порту `5001`.

*   **Маршруты**:
    *   `GET /get`: Отдает основную HTML-страницу читалки.
    *   `GET /api/content`: API-эндпоинт для long-polling. Клиент (читалка) периодически запрашивает этот эндпоинт, чтобы проверить наличие обновлений. Сервер возвращает JSON с HTML-контентом и его хэшем.
    *   `POST /api/content`: Принимает JSON с полем `new_text`. Используется фронтендом для сохранения текста из редактора. Обработчик записывает полученный текст в `AppState`.
    *   `POST /api/url`: Принимает JSON с полем `url`. Используется для отправки ссылки на обработку. Обработчик вызывает `url_processor`, который загружает, очищает и конвертирует статью в Markdown, а затем обновляет `AppState`.

---

### `core.rs`

Содержит изолированную бизнес-логику.

*   **`process_markdown(markdown_text: &str) -> (String, String)`**:
    *   Принимает строку Markdown, преобразует ее в HTML и вычисляет SHA1-хэш.

---

### `url_processor.rs`

*   **`process_url(url_str: &str) -> Result<String, String>`**:
    *   Асинхронная функция, которая загружает веб-страницу по URL, извлекает основной контент с помощью крейта `readability`, очищает HTML от лишних тегов и скриптов с помощью `ammonia` и конвертирует чистый HTML в Markdown.
