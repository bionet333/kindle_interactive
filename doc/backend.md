# Документация: Backend (Tauri + Axum)

Бэкенд-часть приложения построена на Rust и состоит из двух основных компонентов: ядра Tauri для управления десктопным приложением и встроенного веб-сервера Axum для обслуживания E-Ink читалок.

## Структура модулей (`src-tauri/src`)

*   `main.rs`, `lib.rs`: Точки входа. Инициализируют состояние приложения (`AppState`), запускают веб-сервер в отдельном потоке и настраивают обработчики команд Tauri.
*   `state.rs`: Определяет центральное состояние приложения.
*   `commands.rs`: API для взаимодействия с Frontend.
*   `server.rs`: Реализация веб-сервера на Axum.
*   `core.rs`: Чистая бизнес-логика (обработка Markdown).
*   `network.rs`: Сетевые утилиты.

---

### `state.rs`

Отвечает за управление общим состоянием приложения.

*   **`AppState`**: Структура, содержащая все разделяемые данные.
    *   `shared_text: RwLock<String>`: Основной текст в формате Markdown. `RwLock` используется для обеспечения безопасного конкурентного доступа: множество потоков могут читать данные одновременно, но запись возможна только при монопольном доступе.

Экземпляр `AppState` создается один раз при старте приложения и передается во все компоненты (Tauri `State` и Axum `State`) с помощью `Arc` (Atomically Reference-Counted pointer) для безопасного владения в многопоточной среде.

---

### `commands.rs`

Определяет функции, которые можно вызывать из JavaScript-фронтенда.

*   `#[tauri::command]`: Атрибут, который делает функцию доступной для вызова через `invoke` из Yew.

*   **`get_text(state: State<Arc<AppState>>) -> Result<String, String>`**:
    *   Получает `AppState` через механизм внедрения зависимостей Tauri.
    *   Блокирует `shared_text` на чтение и возвращает текущий текст.

*   **`set_text(new_text: String, state: State<Arc<AppState>>) -> Result<(), String>`**:
    *   Получает новый текст от фронтенда.
    *   Блокирует `shared_text` на запись и обновляет его значение.

*   **`get_server_info() -> Result<String, String>`**:
    *   Использует модуль `network` для определения локального IP-адреса.
    *   Формирует и возвращает строку с адресом, который нужно открыть на читалке (например, `http://192.168.1.5:5001/get`).

---

### `server.rs`

Реализует веб-сервер, который отдает контент для читалок.

*   **`run_server(app_state: Arc<AppState>)`**: Асинхронная функция, которая запускает сервер Axum.
    *   Создает `Router` с необходимыми маршрутами.
    *   Использует `with_state` для передачи `AppState` в обработчики маршрутов.
    *   Применяет `CorsLayer` для разрешения кросс-доменных запросов (не обязательно в данном случае, но является хорошей практикой).
    *   Слушает порт `5001` на всех сетевых интерфейсах (`0.0.0.0`).

*   **Маршруты**:
    *   `GET /get`: Отдает основную HTML-страницу читалки. В шаблон `GET_TEMPLATE` встраивается первоначальный контент и его хэш, чтобы избежать дополнительного запроса при первой загрузке.
    *   `GET /api/content`: API-эндпоинт для long-polling. Клиент (читалка) периодически запрашивает этот эндпоинт. Сервер читает `shared_text` из `AppState`, конвертирует его в HTML, вычисляет хэш и возвращает в формате JSON: `{ "html": "...", "hash": "..." }`.

---

### `core.rs`

Содержит изолированную бизнес-логику, не зависящую от фреймворков.

*   **`process_markdown(markdown_text: &str) -> (String, String)`**:
    *   Принимает строку Markdown.
    *   Использует крейт `markdown` для преобразования текста в HTML.
    *   Использует крейт `sha1` для вычисления хэша от сгенерированного HTML.
    *   Возвращает кортеж `(html_content, hash)`.
    *   Эта функция является "чистой" — ее результат зависит только от входных данных.

---

### `network.rs`

*   **`get_local_ip_address() -> Option<String>`**:
    *   Использует крейт `local-ip-address` для определения IP-адреса устройства в локальной сети. Это необходимо для отображения правильного URL для подключения с читалки.
