# Модуль Веб-сервера (`server.rs`)

Этот модуль отвечает за запуск встроенного веб-сервера Axum, который предоставляет контент для E-Ink читалок в локальной сети.

## Ответственность

- Инициализация и запуск легковесного HTTP-сервера на заданном порту (`5001`).
- Обслуживание двух основных эндпоинтов:
    - `/get`: Отдаёт основную HTML-страницу для чтения.
    - `/api/content`: Предоставляет актуальный контент (HTML и хэш) для динамического обновления страницы без перезагрузки.
- Взаимодействие с общим состоянием приложения (`AppState`) для получения актуального Markdown-текста.
- Управление CORS-заголовками для обеспечения доступности с любого устройства в сети.
- **Управление кэшированием**: Сервер отправляет заголовки, запрещающие кэширование (`Cache-Control`, `Pragma`, `Expires`), чтобы гарантировать, что читалка всегда получает самую свежую версию контента. Это ключевой аспект для корректной работы функции "live update".

## API Эндпоинты

### `GET /get`

Отдаёт HTML-страницу, предназначенную для отображения на устройствах с E-Ink экранами.

- **Ответ**: `text/html`
- **Логика**:
    1. Читает текущий текст из `AppState`.
    2. Конвертирует Markdown в HTML.
    3. Встраивает полученный HTML и его SHA1-хэш в основной HTML-шаблон.
    4. Шаблон содержит весь необходимый JavaScript для постраничной навигации и асинхронного опроса сервера на предмет обновлений.

### `GET /api/content`

API-эндпоинт, который используется JavaScript-кодом на странице `/get` для проверки наличия обновлений.

- **Ответ**: `application/json`
- **Структура JSON ответа**:
  ```json
  {
    "html": "...",
    "hash": "..."
  }
  ```
  - `html`: Содержимое, сконвертированное из Markdown в HTML.
  - `hash`: SHA1-хэш от `html` контента. Клиент сравнивает этот хэш с текущим, чтобы определить, нужно ли обновлять страницу.
- **Логика**:
    1. Читает текущий текст из `AppState`.
    2. Вызывает `process_markdown` для получения HTML и хэша.
    3. Сериализует данные в JSON и отправляет клиенту.

## Архитектурные решения

- **Axum**: Выбран как современный, быстрый и модульный веб-фреймворк для Rust.
- **Одно общее состояние (`Arc<AppState>`)**: Сервер работает с тем же состоянием, что и команды Tauri, обеспечивая мгновенную синхронизацию между десктопным редактором и веб-читалкой. Это устраняет необходимость в сложных механизмах синхронизации или базах данных.
- **Асинхронность**: Сервер запускается в отдельном асинхронном потоке (`tauri::async_runtime::spawn`), не блокируя основной поток UI.
