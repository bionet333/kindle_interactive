# Архитектура приложения E-Ink Sync

Система спроектирована по принципам Clean Architecture с четким разделением ответственности между компонентами. Она состоит из трех основных частей:

1.  **Настольное приложение (Tauri)**: Контейнер для веб-интерфейса, обеспечивающий доступ к нативным возможностям и служащий хостом для Rust-бэкенда.
2.  **Frontend (Yew/WASM)**: Пользовательский интерфейс, работающий в браузере (или WebView Tauri). Он отвечает за отображение редактора и взаимодействие с пользователем.
3.  **Backend (Rust/Axum)**: Встроенный в Tauri приложение высокопроизводительный веб-сервер, который отдает контент для E-Ink читалок по локальной сети.

## Поток данных

Диаграмма иллюстрирует взаимодействие между компонентами:

```
[ Пользователь ] --> [ Yew Frontend (Редактор) ]
       |                      | (1. invoke)
       |                      |
       V                      V
[ Tauri Backend ] <-- (2. Обновление State) --> [ AppState (Общее состояние) ]
       |                                                 ^
       | (4. Чтение State)                               |
       V                                                 |
[ Axum Server ] <--- (3. Запрос контента) --- [ E-Ink Читалка ]
```

1.  **Редактирование и сохранение**:
    *   Пользователь вводит Markdown-текст в `textarea` в интерфейсе Yew.
    *   При нажатии кнопки "Сохранить" frontend вызывает Tauri-команду `set_text` через `invoke`, передавая новый текст.

2.  **Обновление состояния**:
    *   Команда `set_text` в Rust-бэкенде получает текст и записывает его в `AppState`.
    *   `AppState` использует `std::sync::RwLock` для обеспечения потокобезопасного доступа к данным, так как к нему одновременно обращаются обработчики команд Tauri и веб-сервер Axum.

3.  **Запрос контента читалкой**:
    *   E-Ink читалка, находящаяся в той же Wi-Fi сети, периодически отправляет GET-запрос на эндпоинт `/api/content` встроенного Axum-сервера.
    *   Frontend-часть читалки (JavaScript) сравнивает хэш полученного контента с текущим.

4.  **Отправка контента**:
    *   Обработчик Axum для `/api/content` читает текущий текст из `AppState`.
    *   Текст обрабатывается (конвертируется из Markdown в HTML), и вычисляется его SHA1-хэш.
    *   Сервер отвечает JSON-объектом, содержащим HTML и хэш. Если хэш изменился, JavaScript на читалке обновляет отображаемый контент.

## Ключевые принципы

*   **Разделение ответственности (SoC)**: Frontend занимается только отображением и вводом, бэкенд - обработкой данных и сетевым взаимодействием, а `AppState` - хранением состояния.
*   **Низкая связанность (Low Coupling)**: Frontend и Backend общаются через четко определенный API (Tauri commands). Веб-сервер и ядро приложения также разделены и взаимодействуют через `AppState`.
*   **Высокая производительность**: Использование Rust, Axum и асинхронной среды выполнения Tokio обеспечивает минимальное потребление ресурсов и быструю обработку запросов, что критично для встроенного сервера.
*   **Единое состояние**: `AppState` выступает в роли "единственного источника правды" (Single Source of Truth), что упрощает синхронизацию данных между различными частями приложения.
