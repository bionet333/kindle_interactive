# Архитектура приложения E-Ink Sync

Система спроектирована по принципам Clean Architecture с четким разделением ответственности между компонентами. Она состоит из трех основных частей:

1.  **Настольное приложение (Tauri)**: Контейнер для веб-интерфейса, обеспечивающий доступ к нативным возможностям (например, мониторинг буфера обмена) и служащий хостом для Rust-бэкенда.
2.  **Frontend (Yew/WASM)**: Пользовательский интерфейс, работающий в браузере (или WebView Tauri). Он отвечает за отображение редактора, поля для URL и взаимодействие с пользователем.
3.  **Backend (Rust/Axum)**: Встроенный в Tauri приложение высокопроизводительный веб-сервер, который отдает контент для E-Ink читалок и принимает данные от фронтенда по локальной сети через HTTP.

## Поток данных

Диаграмма иллюстрирует взаимодействие между компонентами:

```
[ Пользователь ] --> [ Yew Frontend (UI) ]
       |                      |
       |                      | (1a. HTTP POST /api/content - для текста)
       |                      | (1b. HTTP POST /api/url - для ссылки)
       |                      | (1c. invoke() - для контроля, напр. вкл/выкл мониторинга)
       V                      V
[ Tauri Backend ] <-- (2. Обновление State) --> [ AppState (Общее состояние) ]
       ^                      |                                 ^
       | (3. Мониторинг        | (5. Чтение State)               |
       |    буфера обмена)     V                                 |
       |                  [ Axum Server ] <--- (4. Запрос) --- [ E-Ink Читалка ]
       +---------------------------------+
```

1.  **Взаимодействие с UI**:
    *   **1a. Сохранение текста**: Пользователь вводит Markdown-текст и нажимает "Сохранить". Frontend отправляет HTTP POST-запрос с текстом на эндпоинт `/api/content` локального Axum-сервера.
    *   **1b. Отправка URL**: Пользователь вставляет URL и нажимает "Отправить". Frontend отправляет HTTP POST-запрос с URL на эндпоинт `/api/url`.
    *   **1c. Управляющие команды**: Для действий, не связанных с контентом (например, включение мониторинга буфера обмена), Frontend использует Tauri `invoke` для вызова соответствующих Rust-команд.

2.  **Обновление состояния**: 
    *   Обработчики Axum (`/api/content`, `/api/url`) или Tauri-команды получают данные и записывают их в `AppState`.
    *   `AppState` использует `std::sync::RwLock` для обеспечения потокобезопасного доступа к данным.

3.  **Мониторинг буфера обмена**:
    *   Отдельный фоновый поток периодически проверяет буфер обмена. Если находит новую ссылку и функция активна, он напрямую обновляет `AppState`.

4.  **Запрос контента читалкой**:
    *   E-Ink читалка, находящаяся в той же Wi-Fi сети, периодически отправляет GET-запрос на эндпоинт `/api/content` встроенного Axum-сервера.

5.  **Отправка контента**:
    *   Обработчик Axum для `/api/content` читает текущий текст из `AppState`, конвертирует его в HTML, вычисляет хэш и отправляет в виде JSON. JavaScript на читалке сравнивает хэши и при необходимости обновляет контент.

## Ключевые принципы

*   **Разделение ответственности (SoC)**: Frontend занимается только отображением и вводом. Axum-сервер отвечает за API данных. Модули Tauri отвечают за системные интеграции. `AppState` - хранилище состояния.
*   **Низкая связанность (Low Coupling)**: Frontend и Backend-сервер общаются через стандартный HTTP API, что упрощает отладку и тестирование. Для системных вызовов используется API команд Tauri.
*   **Высокая производительность**: Использование Rust, Axum и асинхронной среды выполнения Tokio обеспечивает минимальное потребление ресурсов и быструю обработку запросов.
*   **Единое состояние**: `AppState` выступает в роли "единственного источника правды" (Single Source of Truth), что упрощает синхронизацию данных между различными частями приложения (Tauri-команды, Axum-сервер, фоновые потоки).
